#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_tracing : enable

layout(set = 0, binding = 0) uniform Illum {
	mat4 cam_proj;
	mat4 view;
	mat4 view_normal;
	mat4 view_inv;
	mat4 view_normal_inv;
	mat4 last_view;
	mat4 last_view_inv;
	mat4 view_cur_to_last;
	mat4 view_last_to_cur;
	mat4 view_last_to_cur_normal;
	vec3 rnd_sun[256];
	vec3 rnd_diffuse[256];
	vec3 sun;
	vec2 size;
	vec2 size_inv;
	vec2 depth_size;
	vec2 cam_ratio;
	float cam_near;
	float cam_far;
	float cam_a;
	float cam_b;
} il;

layout(set = 0, binding = 1) uniform accelerationStructureEXT acc;

layout(set = 0, binding = 2) uniform sampler2D cdepth;
layout(set = 0, binding = 3) uniform sampler2D albedo;
layout(set = 0, binding = 4) uniform sampler2D normal;
layout(set = 0, binding = 5) uniform sampler2D last_cdepth;
layout(set = 0, binding = 6) uniform sampler2D last_albedo;
layout(set = 0, binding = 7) uniform sampler2D last_normal;

layout(set = 0, binding = 8, rgba16) uniform image2D out_output;

#include "ray_tracing.glsl"

float rt_depth_to_z(float d)
{
	return il.cam_b / (d -  il.cam_a);
}

float rt_z_to_depth(float z)
{
	return il.cam_b / z + il.cam_a;
}

vec2 rt_ndc_to_ss(vec2 p)
{
	vec2 size = textureSize(albedo, 0);
	return ((p * 0.5) + 0.5) * size;
}

vec3 rt_pos_view(vec2 pos)
{
	vec2 size = vec2(1.0) / textureSize(albedo, 0);
	float d = texelFetch(cdepth, ivec2(pos), 0).x;
	float z = rt_depth_to_z(d);
	vec2 uv = pos * size;
	vec2 ndc2 = (uv - 0.5) * 2.0;
	ndc2 *= il.cam_ratio;
	ndc2 *= z;
	return vec3(ndc2, z);
}

vec3 env_sample_novoid(vec3 dir)
{
	const vec3 hor = vec3(80, 120, 180) / 255;
	const vec3 up = vec3(0, 60, 256) / 255;
	float up_ratio = dot(dir, vec3(0.0, 1.0, 0.0));

	up_ratio = 1.0 - up_ratio;
	up_ratio *= up_ratio;
	up_ratio *= up_ratio;
	up_ratio = 1.0 - up_ratio;
	return normalize(hor * (1.0 - up_ratio) + vec3(1.0) * up);
}

void main(void)
{
	ivec2 pos = ivec2(gl_LaunchIDEXT.xy);
	vec3 view = rt_pos_view(pos);
	traceRayEXT(acc,
		gl_RayFlagsOpaqueEXT,	// rayFlags
		0xFF,	// cullMask
		0,	// sbtRecordOffset
		0,	// sbtRecordStride
		0,	// missIndex
		(il.view_inv * vec4(view, 1.0)).xyz,	// origin
		0.1,	// Tmin
		(il.view_normal_inv * vec4(il.sun, 1.0)).xyz,	// direction
		il.cam_near,	// Tmax
		0);	// payload
	imageStore(out_output, pos, vec4(vec3(rsp.hit ? 0.0 : 1.0), 1.0));
}