#version 460
#extension GL_GOOGLE_include_directive : enable

#include "illum.glsl"

//#include "rtbp.glsl"
#include "rt.glsl"

layout(set = 0, binding = 2, rgba16f) uniform image2DArray s_diffuse;
layout(set = 0, binding = 3, r32f) uniform image2D s_diffuse_acc;
layout(set = 0, binding = 4, rgba16f) uniform image2D s_direct_light;
layout(set = 0, binding = 5, r32f) uniform image2D s_direct_light_acc;
layout(set = 0, binding = 6, rgba16f) uniform image2D s_output;

layout(set = 0, binding = 7) uniform sampler2D cdepth;
layout(set = 0, binding = 8) uniform sampler2D albedo;
layout(set = 0, binding = 9) uniform sampler2D normal;
layout(set = 0, binding = 10) uniform sampler2D normal_geom;
layout(set = 0, binding = 11) uniform sampler2D last_cdepth;
layout(set = 0, binding = 12) uniform sampler2D last_albedo;
layout(set = 0, binding = 13) uniform sampler2D last_normal;
layout(set = 0, binding = 14) uniform sampler2D last_normal_geom;

layout(set = 0, binding = 15) uniform sampler2DArray last_diffuse;
layout(set = 0, binding = 16) uniform sampler2D last_diffuse_acc;
layout(set = 0, binding = 17) uniform sampler2D last_direct_light;
layout(set = 0, binding = 18) uniform sampler2D last_direct_light_acc;

float tmin_calc(float z)
{
	return 0.001 + min((z * 0.001) / il.cam_near, 1.0);
}

vec3 last_pos_view(vec2 pos)
{
	return rt_pos_view(pos, texelFetch(last_cdepth, ivec2(pos), 0).x);
}

float center_divergence(vec2 pos)
{
	vec2 p = abs(fract(pos) - .5);
	return p.x + p.y;
}

const vec3 basis[3] = {
	vec3((2.0 * sqrt(2.0)) / 3.0, 0.0, 1.0 / 3.0),
	vec3(-sqrt(2.0) / 3.0, sqrt(6.0) / 3.0, 1.0 / 3.0),
	vec3(-sqrt(2.0) / 3.0, -sqrt(6.0) / 3.0, 1.0 / 3.0)
};

vec3 basis_w(vec3 normal)
{
	vec3 res = vec3(
		max(0.0, dot(normal, basis[0])),
		max(0.0, dot(normal, basis[1])),
		max(0.0, dot(normal, basis[2]))
	);
	return res / (res.x + res.y + res.z);
}

vec3 normal_view_inv(vec3 normal)
{
	return (il.view_normal_inv * vec4(normal, 1.0)).xyz;
}

vec3 normal_view(vec3 normal)
{
	return (il.view_normal * vec4(normal, 1.0)).xyz;
}

bool nmocc(vec2 fpos, vec3 p, vec3 d)
{
	vec3 p0, p1;
	rt_project_ray(p, d, p0, p1);
	vec2 dir = normalize(p1 - p0).xy;
	if (p.z < .5)
		dir *= 4.0;
	else if (p.z < 1.0)
		dir *= 2.0;
	vec3 slope = vec3(0.0);
	bool disc = false;
	for (uint i = 0; i < 8; i++) {
		slope += textureLod(normal, fpos + dir * i, 0).xyz;
		if (dot(slope * (1.0 / float(i)), d) < 0.0)
			return true;
	}
	return false;
}

void main(void)
{
	vec2 fpos = gl_WorkGroupID.xy + vec2(0.5);
	ivec2 pos = ivec2(fpos);
	vec3 view = rt_pos_view(fpos, texelFetch(cdepth, pos, 0).x);
	vec3 view_norm = normalize(view);
	int rnd = (hash(int(gl_WorkGroupID.x)) + hash(int(gl_WorkGroupID.y))) % 256;

	vec3 sun = (il.view_normal * vec4(il.rnd_sun[rnd], 1.0)).xyz;
	vec3 norm = texelFetch(normal_geom, pos, 0).xyz;
	vec3 alb = texelFetch(albedo, pos, 0).xyz;

	float direct_light = 0.0;

	vec3 out_output;
	vec3 diffuse_b[3];
	for (uint i = 0; i < 3; i++)
		diffuse_b[i] = imageLoad(s_diffuse, ivec3(pos, i)).xyz;
	float acc_diffuse = imageLoad(s_diffuse_acc, pos).x;
	float acc_direct_light = imageLoad(s_direct_light_acc, pos).x;

	vec4 nor_ao = texelFetch(normal, pos, 0);
	float ao = nor_ao.w;
	vec3 nor = nor_ao.xyz;
	vec3 nt, nb;
	vec3 norm_wr = (il.view_normal_inv * vec4(norm, 1.0)).xyz;
	normal_gen_tb(norm_wr, nt, nb);
	vec3 norm_w = basis_w(mat3(
		vec3(nt.x, nb.x, norm_wr.x),
		vec3(nt.y, nb.y, norm_wr.y),
		vec3(nt.z, nb.z, norm_wr.z)
	) * (il.view_normal_inv * vec4(nor, 1.0)).xyz);

	out_output = (direct_light * max(0.0, min(dot(nor, il.sun), dot(norm, il.sun))) * 2.5 + (diffuse_b[0] * norm_w.x + diffuse_b[1] * norm_w.y + diffuse_b[2] * norm_w.z) * ao) * alb;
	if (texelFetch(cdepth, pos, 0).x == 0.0) {
		out_output = env_sample_novoid((il.view_normal_inv * vec4(view_norm, 1.0)).xyz);
		for (uint i = 0; i < 3; i++)
			diffuse_b[i] = vec3(0.0);
		acc_diffuse = 0.0;
		direct_light = 0.0;
		acc_direct_light = 0.0;
	}

	//out_output = diffuse_b_last[0];

	for (uint i = 0; i < 3; i++)
		imageStore(s_diffuse, ivec3(pos, i), vec4(diffuse_b[i], 0.0));
	imageStore(s_diffuse_acc, pos, vec4(acc_diffuse, vec3(0.0)));
	imageStore(s_direct_light, pos, vec4(direct_light, vec3(0.0)));
	imageStore(s_direct_light_acc, pos, vec4(acc_direct_light, vec3(0.0)));
	imageStore(s_output, pos, vec4(out_output, 0.0));
}