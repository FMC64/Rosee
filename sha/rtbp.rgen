#version 460
#extension GL_GOOGLE_include_directive : enable

#include "illum.glsl"
#include "ray_tracing.glsl"

layout(set = 0, binding = 1) uniform accelerationStructureEXT acc;

//#include "rtbp.glsl"
#include "rt.glsl"

layout(set = 0, binding = 2, rgba16f) uniform image2D s_diffuse_cur;
layout(set = 0, binding = 3, rgba16f) uniform image2D s_diffuse;
layout(set = 0, binding = 4, r32f) uniform image2D s_diffuse_acc;
layout(set = 0, binding = 5, rgba16f) uniform image2D s_direct_light_cur;
layout(set = 0, binding = 6, rgba16f) uniform image2D s_direct_light;
layout(set = 0, binding = 7, r32f) uniform image2D s_direct_light_acc;
layout(set = 0, binding = 8, rgba16f) uniform image2D s_output;

layout(set = 0, binding = 9) uniform sampler2D cdepth;
layout(set = 0, binding = 10) uniform sampler2D albedo;
layout(set = 0, binding = 11) uniform sampler2D normal;
layout(set = 0, binding = 12) uniform sampler2D last_cdepth;
layout(set = 0, binding = 13) uniform sampler2D last_albedo;
layout(set = 0, binding = 14) uniform sampler2D last_normal;

layout(set = 0, binding = 15) uniform sampler2D last_diffuse;
layout(set = 0, binding = 16) uniform sampler2D last_diffuse_acc;
layout(set = 0, binding = 17) uniform sampler2D last_direct_light;
layout(set = 0, binding = 18) uniform sampler2D last_direct_light_acc;

layout(location = 0) rayPayloadEXT RayPayload rp;

float tmin_calc(float z)
{
	return 0.00001 + min((z * 0.1) / il.cam_near, 1.0);
}

void main(void)
{
	vec2 fpos = gl_LaunchIDEXT.xy + vec2(0.5);
	ivec2 pos = ivec2(fpos);
	vec3 view = rt_pos_view(fpos, texelFetch(cdepth, pos, 0).x);
	vec3 view_norm = normalize(view);
	int rnd = (hash(int(gl_LaunchIDEXT.x)) + hash(int(gl_LaunchIDEXT.y))) % 256;

	vec3 sun = (il.view_normal * vec4(il.rnd_sun[rnd], 1.0)).xyz;
	vec3 norm = texelFetch(normal, pos, 0).xyz;

	vec3 direct_light = vec3(0.0);

	traceRayEXT(acc,
		gl_RayFlagsCullBackFacingTrianglesEXT,	// rayFlags
		0xFF,	// cullMask
		0,	// sbtRecordOffset
		0,	// sbtRecordStride
		0,	// missIndex
		view,	// origin
		tmin_calc(length(view)),	// Tmin
		sun,	// direction
		il.cam_near * 2.0,	// Tmax
		0);
	if (!rp.hit)
		direct_light += max(0.0, dot(norm, sun)) * 2.5;

	vec3 diffuse = vec3(0.0);
	vec3 first_diffuse_dir = rnd_diffuse_around_rough(view_norm, norm, 0.0, rnd);
	{
		vec3 ray_albedo = vec3(1.0);
		vec3 ray_origin = view;
		vec3 ray_dir = first_diffuse_dir;

		for (uint j = 0; j < 4; j++) {
			traceRayEXT(acc,
				gl_RayFlagsCullBackFacingTrianglesEXT,	// rayFlags
				0xFF,	// cullMask
				0,	// sbtRecordOffset
				0,	// sbtRecordStride
				0,	// missIndex
				ray_origin,	// origin
				tmin_calc(length(ray_origin)),	// Tmin
				ray_dir,	// direction
				il.cam_near * 2.0,	// Tmax
				0);
			if (rp.hit) {
				ray_albedo *= rp.albedo;
				ray_origin = rp.pos;
				vec3 dif_normal = rp.normal;
				ray_dir = rnd_diffuse_around(dif_normal, (hash(int(gl_LaunchIDEXT.x)) + hash(int(gl_LaunchIDEXT.y)) + hash(int(-1 - j * 19))) % 256);

				vec3 sun_dir = sun;

				traceRayEXT(acc,
					gl_RayFlagsCullBackFacingTrianglesEXT,	// rayFlags
					0xFF,	// cullMask
					0,	// sbtRecordOffset
					0,	// sbtRecordStride
					0,	// missIndex
					ray_origin,	// origin
					tmin_calc(length(ray_origin)),	// Tmin
					sun_dir,	// direction
					il.cam_near * 2.0,	// Tmax
					0);
				if (!rp.hit)
					diffuse += ray_albedo * max(0.0, dot(sun_dir, dif_normal)) * 2.5;
			} else {
				diffuse += ray_albedo * env_sample_novoid((il.view_normal_inv * vec4(ray_dir, 1.0)).xyz);
				break;
			}
		}
	}

	imageStore(s_diffuse_cur, pos, vec4(correct_nan(diffuse), 0.0));
	imageStore(s_direct_light_cur, pos, vec4(direct_light, 0.0));
}