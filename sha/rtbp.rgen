#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_KHR_shader_subgroup_basic : enable

#include "illum.glsl"
#include "ray_tracing.glsl"

layout(set = 0, binding = 1) uniform accelerationStructureEXT acc;

//#include "rtbp.glsl"
#include "rt.glsl"

layout(set = 0, binding = 2, rgba16f) uniform image2D s_diffuse;
layout(set = 0, binding = 3, r32f) uniform image2D s_diffuse_acc;
layout(set = 0, binding = 4, rgba16f) uniform image2D s_direct_light;
layout(set = 0, binding = 5, r32f) uniform image2D s_direct_light_acc;
layout(set = 0, binding = 6, rgba16f) uniform image2D s_output;

layout(set = 0, binding = 7) uniform sampler2D cdepth;
layout(set = 0, binding = 8) uniform sampler2D albedo;
layout(set = 0, binding = 9) uniform sampler2D normal;
layout(set = 0, binding = 10) uniform sampler2D normal_geom;
layout(set = 0, binding = 11) uniform sampler2D last_cdepth;
layout(set = 0, binding = 12) uniform sampler2D last_albedo;
layout(set = 0, binding = 13) uniform sampler2D last_normal;
layout(set = 0, binding = 14) uniform sampler2D last_normal_geom;

layout(set = 0, binding = 15) uniform sampler2D last_diffuse;
layout(set = 0, binding = 16) uniform sampler2D last_diffuse_acc;
layout(set = 0, binding = 17) uniform sampler2D last_direct_light;
layout(set = 0, binding = 18) uniform sampler2D last_direct_light_acc;

layout(location = 0) rayPayloadEXT RayPayload rp;

const vec3 b = vec3(10, 5, 0);
const float w = 20.0;
const float h = 10.0;

const vec3 tri_src[3] = {
	b,
	b + vec3(w, 0.0, 0.0),
	b + vec3(0.0, 0.0, h)
};

const float pi = 3.1415926535897932384626433832795;

float acos_fast(float s)
{
	return mix(0, pi, 1 - (s + 1) * .5);
}

struct tri {
	vec3 ps[3];
};

const uint vec_tri_max = 128;

struct vec_tri {
	uint count;
	tri ts[vec_tri_max];
};

// why is that broken??
/*void vec_tri_push(out vec_tri vec, in tri to_push)
{
	vec.ts[vec.count++ & 0xFF] = to_push;
}*/

#define vec_tri_push(vec, to_push) (vec).ts[(vec).count++ & 0xFF] = (to_push)

void occ_ind(in tri src, in tri occ, vec3 p, out vec_tri res)
{
	res.count = 0;
	vec_tri ukn;	// triangles that might be in res and might also be occluded
	ukn.count = 0;
	vec_tri_push(res, src);
}

void occlude(in vec_tri src, in tri occ, vec3 p, out vec_tri res)
{
	res.count = 0;
	vec_tri ind;
	for (uint i = 0; i < src.count; i++) {
		occ_ind(src.ts[i], occ, p, ind);
		for (uint j = 0; j < ind.count; j++)
			vec_tri_push(res, ind.ts[j]);
	}
}

float illum(vec3 p)
{
	vec_tri srcs_nocc;
	{
		tri tl;
		for (int i = 0; i < 3; i++) {
			tl.ps[i] = tri_src[i] - p;
			tl.ps[i].y += il.t;
		}
		srcs_nocc.count = 1;
		srcs_nocc.ts[0] = tl;
	}
	vec_tri srcs;
	occlude(srcs_nocc, tri(vec3[3](
		tri_src[0],
		tri_src[1],
		tri_src[2]
	)), p, srcs);
	float sum = -pi;
	for (uint ti = 0; ti < srcs.count; ti++) {
		tri t = srcs.ts[ti];
		vec3 n[3];
		for (int i = 0; i < 3; i++)
			n[i] = cross(t.ps[i], t.ps[(i + 1) % 3]);
		for (int i = 0; i < 3; i++) {
			vec3 a = n[i];
			vec3 b = n[(i + 1) % 3];
			sum += acos(-dot(a, b) / (length(a) * length(b)));
		}
	}
	sum /= 2.0 * pi;
	return sum;
}

void main(void)
{
	vec2 fpos = gl_LaunchIDEXT.xy + vec2(0.5);
	ivec2 pos = ivec2(fpos);
	vec3 view = rt_pos_view(fpos, texelFetch(cdepth, pos, 0).x);

	vec3 p = (il.view_inv * vec4(view, 1.0)).xyz;

	vec3 out_output = vec3(illum(p));

	imageStore(s_output, pos, vec4(out_output, 0.0));
}