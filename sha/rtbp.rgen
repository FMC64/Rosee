#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_EXT_control_flow_attributes : enable

#include "illum.glsl"
#include "ray_tracing.glsl"

layout(set = 0, binding = 1) uniform accelerationStructureEXT acc;

//#include "rtbp.glsl"
#include "rt.glsl"

layout(set = 0, binding = 2, rgba16f) uniform image2D s_diffuse;
layout(set = 0, binding = 3, r32f) uniform image2D s_diffuse_acc;
layout(set = 0, binding = 4, rgba16f) uniform image2D s_direct_light;
layout(set = 0, binding = 5, r32f) uniform image2D s_direct_light_acc;
layout(set = 0, binding = 6, rgba16f) uniform image2D s_output;

layout(set = 0, binding = 7) uniform sampler2D cdepth;
layout(set = 0, binding = 8) uniform sampler2D albedo;
layout(set = 0, binding = 9) uniform sampler2D normal;
layout(set = 0, binding = 10) uniform sampler2D normal_geom;
layout(set = 0, binding = 11) uniform sampler2D last_cdepth;
layout(set = 0, binding = 12) uniform sampler2D last_albedo;
layout(set = 0, binding = 13) uniform sampler2D last_normal;
layout(set = 0, binding = 14) uniform sampler2D last_normal_geom;

layout(set = 0, binding = 15) uniform sampler2D last_diffuse;
layout(set = 0, binding = 16) uniform sampler2D last_diffuse_acc;
layout(set = 0, binding = 17) uniform sampler2D last_direct_light;
layout(set = 0, binding = 18) uniform sampler2D last_direct_light_acc;

layout(location = 0) rayPayloadEXT RayPayload rp;

const vec3 b = vec3(10, 5, 0);
const float w = 20.0;
const float h = 10.0;

const vec3 tri_src[3] = {
	b,
	b + vec3(w, 0.0, 0.0),
	b + vec3(0.0, 0.0, h)
};

const float pi = 3.1415926535897932384626433832795;

float acos_fast(float s)
{
	return mix(0, pi, 1 - (s + 1) * .5);
}

struct plane {
	vec3 p;
	vec3 n;
};

vec3 plane_proj(in plane pl, vec3 la, vec3 lb)
{
	vec3 v = lb - la;
	float d = dot(pl.p - la, pl.n) / dot(v, pl.n);
	return la + v * d;
}


struct tri {
	vec3 ps[3];
};

tri tri_proj(in tri t, in plane pl)
{
	tri res;
	for (uint i = 0; i < 3; i++)
		res.ps[i] = plane_proj(pl, vec3(0), t.ps[i]);
	return res;
}

const uint vec_tri_max = 128;

struct vec_tri {
	uint count;
	tri ts[vec_tri_max];
};

#define vec_tri_push(vec, to_push) (vec).ts[(vec).count++ & (vec_tri_max - 1)] = (to_push)
#define vec_push(vec, to_push) (vec).ts[(vec).count++] = (to_push)	// no overflow safety variant

struct vec_tri_occ {	// should contain maximum triangles a triangle occluding a triangle can take
	uint count;
	tri ts[16];
};

struct vec_tri_split {	// up to 2 triangles
	uint count;
	tri ts[2];
};

float vec3_det(vec3 a, vec3 b)
{
	return a.x * b.y + a.y * b.z + a.z * b.x - a.z * b.y - a.y * b.x - a.x * b.z;
}

bool seg_inter_line(vec3 p1, vec3 p2, vec3 p3, vec3 p4, out vec3 inter)
{
	vec3 p13 = p1 - p3;
	vec3 p43 = p4 - p3;
	vec3 p21 = p2 - p1;

	float d1343 = dot(p13, p43);
	float d4321 = dot(p43, p21);
	float d1321 = dot(p13, p21);
	float d4343 = dot(p43, p43);
	float d2121 = dot(p21, p21);

	float denom = d2121 * d4343 - d4321 * d4321;
	float numer = d1343 * d4321 - d1321 * d4343;

	float mua = numer / denom;

	inter = p1 + mua * p21;
	return mua > 0 && mua < 1;
}

bool is_same_side(vec3 a, vec3 b, vec3 l0, vec3 l)
{
	vec3 i;
	seg_inter_line(a, b, l0, l, i);
	return dot(a - i, b - i) > 0;
}

const uint split_table[4] = {
	-1,	// undefined
	1,
	0,
	2
};

void quad_to_2tri(vec3 pts[4], out tri[2] tris)
{
	if (dot(pts[0], pts[2]) < dot(pts[1], pts[3])) {
		tris[0] = tri(vec3[3](
			pts[0],
			pts[1],
			pts[2]
		));
		tris[1] = tri(vec3[3](
			pts[0],
			pts[2],
			pts[3]
		));
	} else {
		tris[0] = tri(vec3[3](
			pts[0],
			pts[1],
			pts[3]
		));
		tris[1] = tri(vec3[3](
			pts[3],
			pts[1],
			pts[2]
		));
	}
}

void push_split(in tri s, in vec3 inter[2], uint lit, inout vec_tri_occ lit_out, inout vec_tri_occ other_out)
{
	vec_push(lit_out, tri(vec3[3](
		s.ps[lit],
		inter[0],
		inter[1]
	)));

	tri tris[2];
	quad_to_2tri(vec3[4](
		s.ps[(lit + 1) % 3],
		s.ps[(lit + 2) % 3],
		inter[0],
		inter[1]
	), tris);
	for (uint i = 0; i < 2; i++)
		vec_push(other_out, tris[i]);
}

void tri_split(in tri s, vec3 sla, vec3 slb, vec3 slo, inout vec_tri_occ nocc, inout vec_tri_occ uknocc)
{
	uint count;
	vec3 inter[2];
	uint inter_ndx[2];
	for (uint i = 0; i < 3; i++) {
		vec3 sa = s.ps[i];
		vec3 sb = s.ps[(i + 1) % 3];
		if (seg_inter_line(sa, sb, sla, slb, inter[count])) {
			inter_ndx[count] = i;
			count++;
		}
	}

	if (count != 2) {
		bool isocc = is_same_side(slo, s.ps[0], sla, slb);
		if (isocc)
			vec_push(uknocc, s);
		else
			vec_push(nocc, s);
	} else {
		uint lit = split_table[inter_ndx[0] + inter_ndx[1]];
		bool litocc = is_same_side(slo, s.ps[lit], sla, slb);
		if (litocc)
			push_split(s, inter, lit, uknocc, nocc);
		else
			push_split(s, inter, lit, nocc, uknocc);
	}
}

void occ_ind(in tri src, in plane src_pl, in tri occ, out vec_tri_occ res)
{
	res.count = 0;
	vec_tri_occ ukns;	// triangles that might be in res and might also be occluded
	ukns.count = 1;
	ukns.ts[0] = src;

	// project occluder on light source
	tri proj = tri_proj(occ, src_pl);

	// intersect 3 occluder lines with 3 light source segments
	// at each interation intersection splits each ukn into two sets: nocc and uknocc
	// nocc is definitely not occluded, while uknocc should be added back to ukn for splitting at next iteration
	// each of these sets contains 0 to 2 triangles
	// 0 - split outside of src, other set should contain one element which is the ukn triangle
	// 1 - split divides the ukn triangle in two parts
	//	this part contains one of the three points of such ukn and then can be represented by [this_ukn_point, splitA, splitB]
	//	the other set should contain 2 triangles which form the quad [other_ukn_pointA, other_ukn_pointB, splitA, splitB]
	// 2 - slit inside of src, other set should contain 0 element
	// after last iteration, ukn is discarded and res contains src & !occ
	vec_tri_occ ukns_it;
	vec_tri_split nocc, uknocc;
	for (uint s = 0; s < 3; s++) {	// segment counter
		ukns_it.count = 0;
		for (uint i = 0; i < ukns.count; i++)
			tri_split(ukns.ts[i], proj.ps[s], proj.ps[(s + 1) % 3], proj.ps[(s + 2) % 3], res, ukns_it);
		ukns = ukns_it;
	}
}

void occlude(in vec_tri srcs, in tri occ, out vec_tri res)
{
	res.count = 0;
	vec_tri_occ ind;
	for (uint i = 0; i < srcs.count; i++) {
		tri src = srcs.ts[i];
		plane src_pl = plane(src.ps[0], cross(src.ps[1] - src.ps[0], src.ps[2] - src.ps[0]));
		occ_ind(src, src_pl, occ, ind);
		for (uint j = 0; j < ind.count; j++)
			vec_tri_push(res, ind.ts[j]);
	}
}

float illum(vec3 p)
{
	vec_tri srcs_nocc;
	{
		tri tl;
		for (int i = 0; i < 3; i++) {
			tl.ps[i] = tri_src[i] - p;
			tl.ps[i].y += il.t;
		}
		srcs_nocc.count = 1;
		srcs_nocc.ts[0] = tl;
	}
	vec_tri srcs;
	occlude(srcs_nocc, tri(vec3[3](
		tri_src[0] - p,
		tri_src[1] - p,
		tri_src[2] - p
	)), srcs);
	float sum = -pi;
	for (uint ti = 0; ti < srcs.count; ti++) {
		tri t = srcs.ts[ti];
		vec3 n[3];
		for (int i = 0; i < 3; i++)
			n[i] = cross(t.ps[i], t.ps[(i + 1) % 3]);
		for (int i = 0; i < 3; i++) {
			vec3 a = n[i];
			vec3 b = n[(i + 1) % 3];
			sum += acos(-dot(a, b) / (length(a) * length(b)));
		}
	}
	sum /= 2.0 * pi;
	return sum;
}

void main(void)
{
	vec2 fpos = gl_LaunchIDEXT.xy + vec2(0.5);
	ivec2 pos = ivec2(fpos);
	vec3 view = rt_pos_view(fpos, texelFetch(cdepth, pos, 0).x);

	vec3 p = (il.view_inv * vec4(view, 1.0)).xyz;

	vec3 out_output = vec3(illum(p));

	imageStore(s_output, pos, vec4(out_output, 0.0));
}