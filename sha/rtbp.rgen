#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_KHR_shader_subgroup_basic : enable

#include "illum.glsl"
#include "ray_tracing.glsl"

layout(set = 0, binding = 1) uniform accelerationStructureEXT acc;

//#include "rtbp.glsl"
#include "rt.glsl"

layout(set = 0, binding = 2, rgba16f) uniform image2D s_diffuse;
layout(set = 0, binding = 3, r32f) uniform image2D s_diffuse_acc;
layout(set = 0, binding = 4, rgba16f) uniform image2D s_direct_light;
layout(set = 0, binding = 5, r32f) uniform image2D s_direct_light_acc;
layout(set = 0, binding = 6, rgba16f) uniform image2D s_output;

layout(set = 0, binding = 7) uniform sampler2D cdepth;
layout(set = 0, binding = 8) uniform sampler2D albedo;
layout(set = 0, binding = 9) uniform sampler2D normal;
layout(set = 0, binding = 10) uniform sampler2D normal_geom;
layout(set = 0, binding = 11) uniform sampler2D last_cdepth;
layout(set = 0, binding = 12) uniform sampler2D last_albedo;
layout(set = 0, binding = 13) uniform sampler2D last_normal;
layout(set = 0, binding = 14) uniform sampler2D last_normal_geom;

layout(set = 0, binding = 15) uniform sampler2D last_diffuse;
layout(set = 0, binding = 16) uniform sampler2D last_diffuse_acc;
layout(set = 0, binding = 17) uniform sampler2D last_direct_light;
layout(set = 0, binding = 18) uniform sampler2D last_direct_light_acc;

layout(location = 0) rayPayloadEXT RayPayload rp;

const vec3 b = vec3(10, 5, 0);
const float w = 20.0;
const float h = 10.0;

const vec3 tri_src[3] = {
	b,
	b + vec3(w, 0.0, 0.0),
	b + vec3(0.0, 0.0, h)
};

const float pi = 3.1415926535897932384626433832795;

float acos_fast(float s)
{
	return mix(0, pi, 1 - (s + 1) * .5);
}

struct tri {
	vec3 ps[3];
};

const uint vec_tri_max = 256;

struct vec_tri {
	uint count;
	tri ts[vec_tri_max];
};

void occlude(out vec_tri src, tri occ, vec3 p)
{
}

float illum(vec3 p)
{
	vec_tri srcs;
	{
		tri tl;
		for (int i = 0; i < 3; i++) {
			tl.ps[i] = tri_src[i] - p;
			tl.ps[i].y += il.t;
		}
		srcs.count = 1;
		srcs.ts[0] = tl;
	}
	float sum = -pi;
	for (uint ti = 0; ti < srcs.count; ti++) {
		tri t = srcs.ts[ti];
		vec3 n[3];
		for (int i = 0; i < 3; i++)
			n[i] = cross(t.ps[i], t.ps[(i + 1) % 3]);
		for (int i = 0; i < 3; i++) {
			vec3 a = n[i];
			vec3 b = n[(i + 1) % 3];
			sum += acos(-dot(a, b) / (length(a) * length(b)));
		}
	}
	sum /= 2.0 * pi;
	return sum;
}

void main(void)
{
	vec2 fpos = gl_LaunchIDEXT.xy + vec2(0.5);
	ivec2 pos = ivec2(fpos);
	vec3 view = rt_pos_view(fpos, texelFetch(cdepth, pos, 0).x);

	vec3 p = (il.view_inv * vec4(view, 1.0)).xyz;

	vec3 out_output = vec3(illum(p));

	imageStore(s_output, pos, vec4(out_output, 0.0));
}