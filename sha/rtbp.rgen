#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_KHR_shader_subgroup_basic : enable

#include "illum.glsl"
#include "ray_tracing.glsl"

layout(set = 0, binding = 1) uniform accelerationStructureEXT acc;

//#include "rtbp.glsl"
#include "rt.glsl"

layout(set = 0, binding = 2, rgba16f) uniform image2D s_diffuse;
layout(set = 0, binding = 3, r32f) uniform image2D s_diffuse_acc;
layout(set = 0, binding = 4, rgba16f) uniform image2D s_direct_light;
layout(set = 0, binding = 5, r32f) uniform image2D s_direct_light_acc;
layout(set = 0, binding = 6, rgba16f) uniform image2D s_output;

layout(set = 0, binding = 7) uniform sampler2D cdepth;
layout(set = 0, binding = 8) uniform sampler2D albedo;
layout(set = 0, binding = 9) uniform sampler2D normal;
layout(set = 0, binding = 10) uniform sampler2D normal_geom;
layout(set = 0, binding = 11) uniform sampler2D last_cdepth;
layout(set = 0, binding = 12) uniform sampler2D last_albedo;
layout(set = 0, binding = 13) uniform sampler2D last_normal;
layout(set = 0, binding = 14) uniform sampler2D last_normal_geom;

layout(set = 0, binding = 15) uniform sampler2D last_diffuse;
layout(set = 0, binding = 16) uniform sampler2D last_diffuse_acc;
layout(set = 0, binding = 17) uniform sampler2D last_direct_light;
layout(set = 0, binding = 18) uniform sampler2D last_direct_light_acc;

layout(location = 0) rayPayloadEXT RayPayload rp;

float tmin_calc(float z)
{
	return 0.001 + min((z * 0.001) / il.cam_near, 1.0);
}

vec3 last_pos_view(vec2 pos)
{
	return rt_pos_view(pos, texelFetch(last_cdepth, ivec2(pos), 0).x);
}

float center_divergence(vec2 pos)
{
	vec2 p = abs(fract(pos) - .5);
	return p.x + p.y;
}

const vec3 basis[3] = {
	vec3((2.0 * sqrt(2.0)) / 3.0, 0.0, 1.0 / 3.0),
	vec3(-sqrt(2.0) / 3.0, sqrt(6.0) / 3.0, 1.0 / 3.0),
	vec3(-sqrt(2.0) / 3.0, -sqrt(6.0) / 3.0, 1.0 / 3.0)
};

vec3 basis_w(vec3 normal)
{
	vec3 res = vec3(
		max(0.0, dot(normal, basis[0])),
		max(0.0, dot(normal, basis[1])),
		max(0.0, dot(normal, basis[2]))
	);
	return res / (res.x + res.y + res.z);
}

vec3 normal_view_inv(vec3 normal)
{
	return (il.view_normal_inv * vec4(normal, 1.0)).xyz;
}

vec3 normal_view(vec3 normal)
{
	return (il.view_normal * vec4(normal, 1.0)).xyz;
}

bool nmocc(vec2 fpos, vec3 p, vec3 d)
{
	vec3 p0, p1;
	rt_project_ray(p, d, p0, p1);
	vec2 dir = normalize(p1 - p0).xy;
	if (p.z < .5)
		dir *= 4.0;
	else if (p.z < 1.0)
		dir *= 2.0;
	vec3 slope = vec3(0.0);
	bool disc = false;
	for (uint i = 0; i < 8; i++) {
		slope += textureLod(normal, fpos + dir * i, 0).xyz;
		if (dot(slope * (1.0 / float(i)), d) < 0.0)
			return true;
	}
	return false;
}

const float gauss[5] =
{
	0.05448868, 0.2442013, 0.40262, 0.2442013, 0.05448868
};

bool isValidTap(float tapDepth, float centerDepth, vec3 tapNormal, vec3 centerNormal, float dotViewNormal)
{

	const float depthRelativeDifferenceEpsilonMin = 0.003f;
	const float depthRelativeDifferenceEpsilonMax = 0.02f;
	const float dotNormalsEpsilon = 0.9f;

	// Adjust depth difference epsilon based on view space normal
	float depthRelativeDifferenceEpsilon = mix(depthRelativeDifferenceEpsilonMax, depthRelativeDifferenceEpsilonMin, dotViewNormal);

	// Check depth
	if (abs(1.0f - (tapDepth / centerDepth)) > depthRelativeDifferenceEpsilon) return false;

	// Check normals
	if (dot(tapNormal, centerNormal) < dotNormalsEpsilon) return false;

	return true;
}

float lowPassFilter(vec2 pos, ivec2 filterDirection, float filter_scale, const bool doTemporalFilter)
{
	float ao = 0.0;
	float weight = 1.0;

	float centerDepth = textureLod(last_cdepth, pos, 0).x;
	vec3 centerNormal = textureLod(last_normal, pos, 0).xyz;
	float dotViewNormal = abs(centerNormal.z);

	//float2 offsetScale = filterInfo.texelSize * filterDirection;

	for (int i = -2; i <= 2; ++i) {
		vec2 p = pos + vec2(i * filterDirection) * filter_scale;
		if (p.x >= (il.size.x - 1.0))
			p.x = il.size.x - 1.0;
		if (p.y >= (il.size.y - 1.0))
			p.y = il.size.y - 1.0;

		float tapAO = textureLod(last_diffuse, p, 0).x;
		float tapDepth = textureLod(last_cdepth, p, 0).x;
		vec3 tapNormal = textureLod(last_normal, p, 0).xyz;

		float tapWeight = gauss[i + 2];

		if (isValidTap(tapDepth, centerDepth, tapNormal, centerNormal, dotViewNormal) || i == 0) {
			ao += (doTemporalFilter
				? tapAO * 0.25
				: tapAO) * tapWeight;
		}else
			weight -= tapWeight;
	}

	ao /= weight;

	return ao;
}

void main(void)
{
	vec2 fpos = gl_LaunchIDEXT.xy + vec2(0.5);
	ivec2 pos = ivec2(fpos);
	vec3 view = rt_pos_view(fpos, texelFetch(cdepth, pos, 0).x);
	vec3 view_norm = normalize(view);
	int rnd = (hash(int(gl_LaunchIDEXT.x)) + hash(int(gl_LaunchIDEXT.y))) % 2048;

	vec3 norm = texelFetch(normal_geom, pos, 0).xyz;

	vec3 first_diffuse_dir = normal_view(rnd_diffuse_around(normal_view_inv(norm), rnd));
	traceRayEXT(acc,
		gl_RayFlagsCullBackFacingTrianglesEXT,	// rayFlags
		0xFF,	// cullMask
		0,	// sbtRecordOffset
		0,	// sbtRecordStride
		0,	// missIndex
		view,	// origin
		0.0,	// Tmin
		first_diffuse_dir,	// direction
		il.cam_near * 2.0,	// Tmax
		0);

	vec4 last_view = il.view_cur_to_last * vec4(view, 1.0);
	vec2 last_view_pos = rt_project_point(last_view.xyz).xy;
	ivec2 ilast_view_pos = ivec2(last_view_pos);

	const float repr_dist_tres = 0.5;
	float repr_dist = length((il.view_inv * vec4(view, 1.0)).xyz - (il.last_view_inv * vec4(last_pos_view(last_view_pos), 1.0)).xyz);
	bool repr_success = last_view_pos.x >= 0 && last_view_pos.y >= 0 &&
		last_view_pos.x <= (il.size.x) && last_view_pos.y <= (il.size.y) &&
		repr_dist < repr_dist_tres;
	float filter_scale = 1.0;
	{
		vec3 base_normal = texelFetch(last_normal_geom, ilast_view_pos, 0).xyz;
		if (length(textureLod(last_normal_geom, last_view_pos, 0.0).xyz - base_normal) >= 0.05) {
			//repr_success = false;
			const ivec2 offsets[8] = {
				ivec2(-1, 0),
				ivec2(1, 0),
				ivec2(0, -1),
				ivec2(1, 1),

				ivec2(-1, -1),
				ivec2(1, -1),
				ivec2(-1, 1),
				ivec2(1, 1)
			};
			for (uint i = 0; i < 8; i++) {
				vec2 cur = last_view_pos + vec2(offsets[i]);
				if (length(textureLod(last_normal_geom, cur, 0.0).xyz - base_normal) < 0.01) {
					last_view_pos = cur;
					ilast_view_pos = ivec2(cur);
					break;
				}
			}
			filter_scale = 0.0;
		}
	}

	vec3 alb = texelFetch(albedo, pos, 0).xyz;

	float acc_diffuse = 1.0;
	vec2 diffuse = vec2(rp.hit ? 0.0 : 1.0);
	vec2 used_diffuse = diffuse;
	if (repr_success) {
		const float limit = 128.0;
		float last_acc = textureLod(last_diffuse_acc, last_view_pos, 0).x;
		if (last_acc < limit * .5)
			filter_scale *= 4.0;
		else if (last_acc < limit * .75)
			filter_scale *= 2.0;
		else
			filter_scale = 2.0;
		/*if (last_acc > 8.0) {
			float d = textureLod(last_diffuse, last_view_pos, 0).x;
			if (d < 0.01)
				filter_scale = 0.5;
		}*/
		float has_diffuse = textureLod(last_diffuse, last_view_pos, 0).y;
		vec2 last_acc2 = vec2(last_acc);

		{
			float s = 8;
			float v1 = 1.0 - abs(textureLod(last_diffuse, last_view_pos + vec2(-s, -s), 0).y - textureLod(last_diffuse, last_view_pos + vec2(s, s), 0).y);
			float v2 = 1.0 - abs(textureLod(last_diffuse, last_view_pos + vec2(s, -s), 0).y - textureLod(last_diffuse, last_view_pos + vec2(-s, s), 0).y);
			float s2 = pow(min(v1, v2), 2.0);
			if (s2 < 0.80 || has_diffuse == 0.0)
				filter_scale = 0.1;
			else if (s2 < 0.85)
				filter_scale = .5;
			//else
			//	s2 =
			//s2 = pow(s2, 16.0);
			//s2 = pow(s2, 4.0);
			//filter_scale *= s2;
		}

		/*if (last_acc > 16.0) {
			if (length(fract(last_view_pos) - .5) > 0.01) {
				last_acc2.y = 4.0;
				/*vec4 g = textureGather(last_diffuse, last_view_pos, 1);
				if (uint(last_acc) % 2 == 0)
					has_diffuse = min(g.x, min(g.y, min(g.z, g.w)));
				else
					has_diffuse = max(g.x, max(g.y, max(g.z, g.w)));*/
			//}
			//if (has_diffuse == 0)
			//	filter_scale = 0.01;
		//}
		float fdiffuse = lowPassFilter(last_view_pos, uint(last_acc) % 2 == 0 ? ivec2(1, 0) : ivec2(0, 1), filter_scale, false);
		used_diffuse = vec2(fdiffuse);
		acc_diffuse = last_acc + 1.0;
		diffuse = (vec2(fdiffuse, has_diffuse) * last_acc2 + diffuse) / vec2(acc_diffuse, last_acc2.y + 1.0);
		if (acc_diffuse >= limit)
			acc_diffuse = limit - 2.0;
	}

	vec3 out_output = alb * used_diffuse.x;

	if (texelFetch(cdepth, pos, 0).x == 0.0) {
		out_output = vec3(1.0);
	}

	//acc_diffuse = min(acc_diffuse, 24.0);
	imageStore(s_diffuse, pos, vec4(diffuse, 0.0, 0.0));
	imageStore(s_diffuse_acc, pos, vec4(acc_diffuse, vec3(0.0)));
	//imageStore(s_direct_light, pos, vec4(direct_light, vec3(0.0)));
	//imageStore(s_direct_light_acc, pos, vec4(acc_direct_light, vec3(0.0)));
	imageStore(s_output, pos, vec4(out_output, 0.0));
}