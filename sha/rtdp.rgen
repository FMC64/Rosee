#version 460
#extension GL_GOOGLE_include_directive : enable

#include "illum.glsl"
#include "ray_tracing.glsl"

layout(set = 0, binding = 1) uniform accelerationStructureEXT acc;

#include "rtdp.glsl"
#include "rt.glsl"

layout(set = 0, binding = 6, rgba16f) uniform image2DArray s_probes;

layout(location = 0) rayPayloadEXT RayPayload rp;

float tmin_calc(float z)
{
	return 0.00001 + min((z * 0.1) / il.cam_near, 1.0);
}

void main(void)
{
	ivec2 pos = ivec2(gl_LaunchIDEXT.xy);

	ivec2 probe_pos = pos / probe_diffuse_size_next;
	ivec2 probe_pos_loc = pos % probe_diffuse_size_next;
	ivec2 probe_pos_base = probe_pos * probe_diffuse_size;
	ivec2 pos_out = 1 + probe_pos_base + probe_pos_loc;
	vec3 dir = probe_pos_to_dir(probe_pos_loc);

	ivec2 offs[8];
	uint off_count = oct_fill_mirror(probe_pos_loc, offs);

	for (uint i = 0; i < probe_layer_count; i++) {
		Probe probe = probes_pos.probes[(probe_pos.y * il.probe_extent.x + probe_pos.x) * probe_layer_count + i];
		vec3 out_probe;

		traceRayEXT(acc,
			gl_RayFlagsCullBackFacingTrianglesEXT,	// rayFlags
			0xFF,	// cullMask
			0,	// sbtRecordOffset
			0,	// sbtRecordStride
			0,	// missIndex
			probe.pos,	// origin
			tmin_calc(length(probe.pos)),	// Tmin
			dir,	// direction
			il.cam_near * 2.0,	// Tmax
			0);
		if (rp.hit)
			out_probe = rp.albedo;
		else
			out_probe = vec3(0.0);

		imageStore(s_probes, ivec3(pos_out, i), vec4(out_probe, 1.0));

		for (uint j = 0; j < 8; j++) {
			if (j >= off_count)
				break;
			imageStore(s_probes, ivec3(probe_pos_base + offs[j], i), vec4(out_probe, 1.0));
		}
	}
}